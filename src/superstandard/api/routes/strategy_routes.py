"""
NEXUS Strategy Management API Routes

Exposes strategy storage, versioning, and performance tracking functionality.

Features:
- Save and retrieve AI-generated strategies
- Version control and history
- Performance metrics tracking
- Strategy comparison and ranking
- Integration with backtesting results

Endpoints:
- POST /api/strategies - Save strategy
- GET /api/strategies - List strategies
- GET /api/strategies/{id} - Get strategy details
- PUT /api/strategies/{id} - Update strategy
- DELETE /api/strategies/{id} - Delete strategy
- GET /api/strategies/{id}/backtests - Get strategy backtest history
- GET /api/strategies/top - Get top-performing strategies
- POST /api/strategies/compare - Compare multiple strategies
"""

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field
from typing import Dict, List, Any, Optional
from datetime import datetime

# Import strategy storage
try:
    from superstandard.trading.strategy_storage import (
        StrategyStorage,
        Strategy,
        BacktestResult,
        get_storage
    )
    STORAGE_AVAILABLE = True
except ImportError as e:
    print(f"⚠️ Strategy storage not available: {e}")
    STORAGE_AVAILABLE = False

router = APIRouter(prefix="/api/strategies", tags=["strategies"])


# ============================================================================
# Pydantic Models
# ============================================================================

class StrategyCreate(BaseModel):
    """Request to create/save a strategy"""
    name: str = Field(..., min_length=1, max_length=200)
    description: str = Field(default="", max_length=1000)
    strategy_type: str = Field(default="ai_generated")
    code: str = Field(..., min_length=1)
    parameters: Dict[str, Any] = Field(default_factory=dict)
    tags: List[str] = Field(default_factory=list)
    parent_strategy_id: Optional[str] = None

    class Config:
        json_schema_extra = {
            "example": {
                "name": "AI SMA Crossover v1",
                "description": "Simple Moving Average crossover strategy generated by autonomous agent",
                "strategy_type": "ai_generated",
                "code": "async def strategy(timestamp, bar, historical_data, fast=10, slow=30):\n    # Strategy logic...\n    return signal",
                "parameters": {
                    "fast_period": 10,
                    "slow_period": 30,
                    "position_size": 0.95
                },
                "tags": ["momentum", "ai_generated", "sma"]
            }
        }


class StrategyUpdate(BaseModel):
    """Request to update strategy"""
    name: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    code: Optional[str] = Field(None, min_length=1)
    parameters: Optional[Dict[str, Any]] = None
    tags: Optional[List[str]] = None
    is_active: Optional[bool] = None
    is_favorite: Optional[bool] = None


class StrategyResponse(BaseModel):
    """Strategy response model"""
    id: str
    name: str
    description: str
    strategy_type: str
    code: str
    parameters: Dict[str, Any]
    created_by: str
    created_at: str
    updated_at: str
    version: int
    parent_strategy_id: Optional[str]
    total_backtests: int
    best_sharpe_ratio: Optional[float]
    best_total_return_pct: Optional[float]
    avg_win_rate: Optional[float]
    is_active: bool
    is_favorite: bool
    tags: List[str]


class BacktestLinkRequest(BaseModel):
    """Link backtest result to strategy"""
    backtest_id: str
    strategy_id: str
    strategy_version: int
    symbol: str
    start_date: str
    end_date: str
    timeframe: str
    initial_capital: float
    total_return_pct: float
    sharpe_ratio: float
    sortino_ratio: float
    max_drawdown_pct: float
    win_rate: float
    total_trades: int
    profit_factor: float
    duration_seconds: Optional[float] = None


class CompareRequest(BaseModel):
    """Request to compare strategies"""
    strategy_ids: List[str] = Field(..., min_items=2, max_items=10)


# ============================================================================
# Strategy Management Endpoints
# ============================================================================

@router.post("", response_model=Dict[str, Any])
async def create_strategy(request: StrategyCreate) -> Dict[str, Any]:
    """
    Save a new strategy

    Creates a new strategy in the database with version 1.
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Create Strategy object
    strategy = Strategy(
        name=request.name,
        description=request.description,
        strategy_type=request.strategy_type,
        code=request.code,
        parameters=request.parameters,
        tags=request.tags,
        parent_strategy_id=request.parent_strategy_id
    )

    # Save to database
    strategy_id = storage.save_strategy(strategy)

    return {
        "strategy_id": strategy_id,
        "status": "created",
        "version": 1,
        "message": "Strategy saved successfully"
    }


@router.get("", response_model=List[StrategyResponse])
async def list_strategies(
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    sort_by: str = Query("created_at", regex="^(created_at|best_sharpe_ratio|best_total_return_pct|name)$"),
    filter_type: Optional[str] = Query(None),
    filter_tags: Optional[str] = Query(None, description="Comma-separated tags"),
    active_only: bool = Query(True)
) -> List[StrategyResponse]:
    """
    List strategies with filtering and sorting

    Query Parameters:
    - limit: Maximum number of strategies (default: 50, max: 200)
    - offset: Pagination offset (default: 0)
    - sort_by: Sort field (created_at, best_sharpe_ratio, best_total_return_pct, name)
    - filter_type: Filter by strategy_type (ai_generated, manual, evolved)
    - filter_tags: Comma-separated list of tags
    - active_only: Only return active strategies (default: true)
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Parse tags
    tags = filter_tags.split(",") if filter_tags else None

    # Query database
    strategies = storage.list_strategies(
        limit=limit,
        offset=offset,
        sort_by=sort_by,
        filter_type=filter_type,
        filter_tags=tags,
        active_only=active_only
    )

    # Convert to response models
    return [
        StrategyResponse(
            id=s.id,
            name=s.name,
            description=s.description,
            strategy_type=s.strategy_type,
            code=s.code,
            parameters=s.parameters,
            created_by=s.created_by,
            created_at=s.created_at,
            updated_at=s.updated_at,
            version=s.version,
            parent_strategy_id=s.parent_strategy_id,
            total_backtests=s.total_backtests,
            best_sharpe_ratio=s.best_sharpe_ratio,
            best_total_return_pct=s.best_total_return_pct,
            avg_win_rate=s.avg_win_rate,
            is_active=s.is_active,
            is_favorite=s.is_favorite,
            tags=s.tags
        )
        for s in strategies
    ]


@router.get("/{strategy_id}", response_model=StrategyResponse)
async def get_strategy(
    strategy_id: str,
    version: Optional[int] = Query(None, description="Specific version (default: latest)")
) -> StrategyResponse:
    """
    Get strategy by ID

    Optionally specify version to retrieve historical version.
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()
    strategy = storage.get_strategy(strategy_id, version=version)

    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")

    return StrategyResponse(
        id=strategy.id,
        name=strategy.name,
        description=strategy.description,
        strategy_type=strategy.strategy_type,
        code=strategy.code,
        parameters=strategy.parameters,
        created_by=strategy.created_by,
        created_at=strategy.created_at,
        updated_at=strategy.updated_at,
        version=strategy.version,
        parent_strategy_id=strategy.parent_strategy_id,
        total_backtests=strategy.total_backtests,
        best_sharpe_ratio=strategy.best_sharpe_ratio,
        best_total_return_pct=strategy.best_total_return_pct,
        avg_win_rate=strategy.avg_win_rate,
        is_active=strategy.is_active,
        is_favorite=strategy.is_favorite,
        tags=strategy.tags
    )


@router.put("/{strategy_id}", response_model=Dict[str, Any])
async def update_strategy(strategy_id: str, request: StrategyUpdate) -> Dict[str, Any]:
    """
    Update strategy

    Updates strategy and increments version number.
    Previous versions are preserved in history.
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Get existing strategy
    strategy = storage.get_strategy(strategy_id)
    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")

    # Update fields
    if request.name is not None:
        strategy.name = request.name
    if request.description is not None:
        strategy.description = request.description
    if request.code is not None:
        strategy.code = request.code
    if request.parameters is not None:
        strategy.parameters = request.parameters
    if request.tags is not None:
        strategy.tags = request.tags
    if request.is_active is not None:
        strategy.is_active = request.is_active
    if request.is_favorite is not None:
        strategy.is_favorite = request.is_favorite

    # Save (will increment version)
    storage.save_strategy(strategy)

    return {
        "strategy_id": strategy_id,
        "status": "updated",
        "version": strategy.version,
        "message": "Strategy updated successfully"
    }


@router.delete("/{strategy_id}")
async def delete_strategy(strategy_id: str) -> Dict[str, str]:
    """
    Delete strategy

    Deletes strategy and all associated data (backtests, versions).
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Check if exists
    strategy = storage.get_strategy(strategy_id)
    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")

    # Delete
    storage.delete_strategy(strategy_id)

    return {
        "status": "success",
        "message": f"Strategy {strategy_id} deleted"
    }


# ============================================================================
# Backtest Integration
# ============================================================================

@router.post("/{strategy_id}/backtests")
async def link_backtest_result(strategy_id: str, request: BacktestLinkRequest) -> Dict[str, Any]:
    """
    Link backtest result to strategy

    Saves backtest result and updates strategy performance metrics.
    This should be called after completing a backtest.
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Verify strategy exists
    strategy = storage.get_strategy(strategy_id)
    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")

    # Create BacktestResult
    result = BacktestResult(
        id=request.backtest_id,
        strategy_id=strategy_id,
        strategy_version=request.strategy_version,
        symbol=request.symbol,
        start_date=request.start_date,
        end_date=request.end_date,
        timeframe=request.timeframe,
        initial_capital=request.initial_capital,
        total_return_pct=request.total_return_pct,
        sharpe_ratio=request.sharpe_ratio,
        sortino_ratio=request.sortino_ratio,
        max_drawdown_pct=request.max_drawdown_pct,
        win_rate=request.win_rate,
        total_trades=request.total_trades,
        profit_factor=request.profit_factor,
        created_at=datetime.utcnow().isoformat(),
        duration_seconds=request.duration_seconds
    )

    # Save
    storage.save_backtest_result(result)

    return {
        "status": "success",
        "message": "Backtest result linked to strategy",
        "strategy_id": strategy_id,
        "backtest_id": request.backtest_id
    }


@router.get("/{strategy_id}/backtests")
async def get_strategy_backtests(
    strategy_id: str,
    limit: int = Query(20, ge=1, le=100)
) -> List[Dict[str, Any]]:
    """
    Get backtest history for strategy

    Returns list of all backtests run for this strategy, sorted by date (newest first).
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Verify strategy exists
    strategy = storage.get_strategy(strategy_id)
    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")

    # Get backtests
    backtests = storage.get_strategy_backtests(strategy_id, limit=limit)

    return [
        {
            "backtest_id": b.id,
            "strategy_version": b.strategy_version,
            "symbol": b.symbol,
            "start_date": b.start_date,
            "end_date": b.end_date,
            "timeframe": b.timeframe,
            "initial_capital": b.initial_capital,
            "total_return_pct": b.total_return_pct,
            "sharpe_ratio": b.sharpe_ratio,
            "sortino_ratio": b.sortino_ratio,
            "max_drawdown_pct": b.max_drawdown_pct,
            "win_rate": b.win_rate,
            "total_trades": b.total_trades,
            "profit_factor": b.profit_factor,
            "created_at": b.created_at,
            "duration_seconds": b.duration_seconds
        }
        for b in backtests
    ]


# ============================================================================
# Strategy Analysis & Ranking
# ============================================================================

@router.get("/top/performers")
async def get_top_strategies(
    metric: str = Query("sharpe_ratio", regex="^(sharpe_ratio|total_return_pct|win_rate)$"),
    limit: int = Query(10, ge=1, le=50)
) -> List[Dict[str, Any]]:
    """
    Get top-performing strategies

    Ranks strategies by specified metric.

    Metrics:
    - sharpe_ratio: Risk-adjusted returns
    - total_return_pct: Absolute returns
    - win_rate: Winning trade percentage
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()
    top_strategies = storage.get_top_strategies(metric=metric, limit=limit)

    return [
        {
            "strategy": {
                "id": strategy.id,
                "name": strategy.name,
                "description": strategy.description,
                "type": strategy.strategy_type,
                "tags": strategy.tags
            },
            "metrics": metrics,
            "rank": idx + 1
        }
        for idx, (strategy, metrics) in enumerate(top_strategies)
    ]


@router.post("/compare")
async def compare_strategies(request: CompareRequest) -> Dict[str, Any]:
    """
    Compare multiple strategies side-by-side

    Provides detailed comparison of 2-10 strategies with metrics and winners by category.
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    storage = get_storage()

    # Verify all strategies exist
    for strategy_id in request.strategy_ids:
        if not storage.get_strategy(strategy_id):
            raise HTTPException(status_code=404, detail=f"Strategy {strategy_id} not found")

    # Compare
    comparison = storage.compare_strategies(request.strategy_ids)

    return comparison


@router.get("/health")
async def health_check() -> Dict[str, Any]:
    """Check strategy storage system health"""
    if not STORAGE_AVAILABLE:
        return {
            "status": "unavailable",
            "storage_available": False
        }

    storage = get_storage()

    # Get counts
    all_strategies = storage.list_strategies(limit=10000, active_only=False)
    active_strategies = storage.list_strategies(limit=10000, active_only=True)

    return {
        "status": "healthy",
        "storage_available": True,
        "total_strategies": len(all_strategies),
        "active_strategies": len(active_strategies),
        "inactive_strategies": len(all_strategies) - len(active_strategies)
    }


# ============================================================================
# AI Integration Helper (for autonomous strategy agent)
# ============================================================================

@router.post("/ai/auto-save")
async def auto_save_ai_strategy(
    name: str = Query(..., description="Strategy name"),
    code: str = Query(..., description="Strategy code"),
    parameters: Optional[str] = Query(None, description="JSON parameters"),
    tags: Optional[str] = Query(None, description="Comma-separated tags")
) -> Dict[str, Any]:
    """
    Auto-save strategy from AI agent

    Simplified endpoint for autonomous agents to save strategies without full request body.
    """
    if not STORAGE_AVAILABLE:
        raise HTTPException(status_code=503, detail="Strategy storage not available")

    import json

    storage = get_storage()

    # Parse parameters
    params = json.loads(parameters) if parameters else {}
    tag_list = tags.split(",") if tags else ["ai_generated"]

    # Create strategy
    strategy = Strategy(
        name=name,
        description=f"AI-generated strategy created at {datetime.utcnow().isoformat()}",
        strategy_type="ai_generated",
        code=code,
        parameters=params,
        tags=tag_list,
        created_by="autonomous_strategy_agent"
    )

    # Save
    strategy_id = storage.save_strategy(strategy)

    return {
        "strategy_id": strategy_id,
        "status": "created",
        "message": "AI strategy auto-saved successfully"
    }

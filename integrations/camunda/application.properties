# SuperStandard PCF Camunda Integration Configuration
# =======================================================

# Server Configuration
# -----------------------
server.port=8080

# Application Information
spring.application.name=SuperStandard PCF Camunda Integration

# Camunda BPM Configuration
# ---------------------------
# Enable auto-deployment of BPMN files
camunda.bpm.auto-deployment-enabled=true

# Admin user for Camunda web apps
camunda.bpm.admin-user.id=admin
camunda.bpm.admin-user.password=admin
camunda.bpm.admin-user.firstName=Admin
camunda.bpm.admin-user.lastName=User
camunda.bpm.admin-user.email=admin@superstandard.ai

# Filter for additional users (enable for production)
# camunda.bpm.filter.create=All tasks

# Job Executor Configuration
camunda.bpm.job-execution.enabled=true
camunda.bpm.job-execution.core-pool-size=3
camunda.bpm.job-execution.max-pool-size=10
camunda.bpm.job-execution.queue-capacity=10

# History Level (FULL for production monitoring)
camunda.bpm.history-level=FULL

# Database Configuration
# ------------------------
# H2 (Development) - in-memory database
spring.datasource.url=jdbc:h2:mem:camunda;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# H2 Console (for development debugging)
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console

# PostgreSQL (Production) - uncomment and configure for production
# spring.datasource.url=jdbc:postgresql://localhost:5432/camunda
# spring.datasource.driver-class-name=org.postgresql.Driver
# spring.datasource.username=camunda
# spring.datasource.password=camunda

# JPA Configuration
spring.jpa.show-sql=false
spring.jpa.hibernate.ddl-auto=update

# SuperStandard PCF Agent API Configuration
# -------------------------------------------
# Base URL of PCF Agent API
pcf.api.base-url=http://localhost:8000

# Timeout for agent execution (seconds)
pcf.api.timeout-seconds=300

# Enable KPI tracking
pcf.api.track-kpis=true

# Enable hierarchical delegation
pcf.api.delegate-to-children=true

# Logging Configuration
# -----------------------
# Root logging level
logging.level.root=INFO

# Camunda logging
logging.level.org.camunda=INFO

# PCF Agent Delegate logging
logging.level.ai.superstandard.camunda.delegate=DEBUG

# Spring logging
logging.level.org.springframework=INFO

# SQL logging (for debugging)
# logging.level.org.hibernate.SQL=DEBUG
# logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Log pattern
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n

# Actuator Configuration (for health checks)
# --------------------------------------------
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always

# BPMN Deployment Configuration
# -------------------------------
# Location of BPMN files (relative to resources)
spring.resources.static-locations=classpath:/bpmn/

# REST API Configuration (Camunda REST)
# ---------------------------------------
# Enable Camunda REST API
camunda.bpm.rest.enabled=true

# CORS Configuration (for web-based clients)
# --------------------------------------------
# Allow CORS for Camunda web apps
camunda.bpm.webapp.cors.enabled=true
camunda.bpm.webapp.cors.allowed-origins=*

# Spring CORS Configuration
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# =========================================================
# PRODUCTION CONFIGURATION NOTES
# =========================================================
#
# For production deployment:
#
# 1. DATABASE:
#    - Switch to PostgreSQL or MySQL
#    - Configure connection pooling
#    - Enable SSL for database connections
#
# 2. SECURITY:
#    - Change admin password
#    - Enable authentication/authorization
#    - Configure LDAP/Active Directory integration
#    - Restrict CORS origins
#
# 3. PCF API:
#    - Update pcf.api.base-url to production URL
#    - Enable API authentication (API keys/OAuth)
#    - Configure retry logic
#    - Set up circuit breakers
#
# 4. MONITORING:
#    - Enable Camunda metrics
#    - Configure application monitoring (Prometheus, Grafana)
#    - Set up log aggregation (ELK stack)
#    - Enable distributed tracing
#
# 5. PERFORMANCE:
#    - Tune job executor pool sizes
#    - Configure database connection pooling
#    - Enable caching where appropriate
#    - Set appropriate timeout values
#
# 6. HIGH AVAILABILITY:
#    - Deploy multiple Camunda instances
#    - Configure load balancing
#    - Set up database clustering
#    - Implement health checks
#
# =========================================================

# Example Production Configuration:
# -----------------------------------
# spring.datasource.url=jdbc:postgresql://db.production:5432/camunda
# spring.datasource.username=${DB_USERNAME}
# spring.datasource.password=${DB_PASSWORD}
# spring.datasource.hikari.maximum-pool-size=20
# spring.datasource.hikari.minimum-idle=5
#
# pcf.api.base-url=https://api.superstandard.ai
# pcf.api.timeout-seconds=600
#
# camunda.bpm.admin-user.password=${ADMIN_PASSWORD}
#
# logging.level.root=WARN
# logging.level.ai.superstandard=INFO
#
# management.endpoints.web.exposure.include=health,metrics,prometheus
